## 设计模式

### 命令模式
* 定义:   
    命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。
* 说明
* 范例
    命令接口、 实现接口的命令类、调用命令的类

* 优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。

* 缺点：使用命令模式可能会导致某些系统有过多的具体命令类。
### 工厂方法模式

* 定义:   这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。
* 说明：  
* 范例：  工厂类
* 优点：    1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。
* 缺点：    每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

### 状态模式

* 定义:   在状态模式（State Pattern）中，类的行为是基于它的状态改变的。
* 说明：  游戏状态，场景转换等等
* 范例：  每个状态对应一个类
* 优点：    1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。
* 缺点：     1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对"开闭原则"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。

### 外观模式（Facade）

* 定义:   外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。
* 说明：  降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。
* 范例：  
* 优点：    1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。
* 缺点：    不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。

### 单例模式（Singleton）
* 定义:   单例模式（Singleton），保证了全局有且只有一个实例对象，保证自动地初始化该对象，使得程序在任何时候任何地方都可以访问、获取该对象。
* 说明：  把构造函数定义为private或protected，可以防止外界利用new创建此类实例。而且GetInstance是一个静态的函数，主要负责创建自己的唯一实例。而且GetInstance是一个静态的函数，主要负责创建自己的唯一实例。

但有时候，在多线程的程序中，多个线程同时访问Singleton，调用GetInstance()方法，会有可能造成创建多个实例。这时候就要给程序加锁。

* 范例：  
```
        使用单例模板，将会使代码更加简洁：
        public abstract class Singleton<T> : MonoBehaviour where T : MonoBehaviour
        {
            //单例
            private static T instance;
            public static T Instance
            {
                get
                {
                    if (instance == null)
                    {
                        instance = FindObjectOfType(typeof(T)) as T;
                        if (instance == null)
                        {
                            GameObject newObj = new GameObject(typeof(T).ToString());
                            instance = newObj.AddComponent<T>();
                        }
                    }
                    return instance;
                }
            }
        }
        //使用示例
        public class SingletonDemo : Singleton<SingletonDemo>
        {

        }
```

* 优点：  
    1、唯一性质（限制对象的产生数量）
    2、方便调用（提供方便获取唯一对象的方法）  
* 缺点：
    容易让人产生“单例癖”，单例癖主要是想“省略参数传递”和“能快速获取唯一对象”，从而滥用单例模式。
    容易造成设计思考不周和过度使用的问题，不是说完全不让使用，而是应该仔细设计和特定的前提之下，适当地采用单例模式。

### 中介者模式（Mediator）

* 定义:   定义一个接口来封装一群对象的互动行为。中介者通过移除对象之间的引用，来减少它们之间的耦合度，并且能改变它们之间的互动性。

* 说明：  
* 范例：  
* 优点：
    1.降低了系统对象之间的耦合性，使得对象易于独立的被复用。
    2.提高系统的灵活性，使得系统易于扩展和维护。    
* 缺点：
    中介者模式的缺点是显而易见的，因为这个“中介“承担了较多的责任，所以一旦这个中介对象出现了问题，那么整个系统就会受到重大的影响。

### 桥接模式（Bridge）

* 定义:   将抽象与实现分离，使二者可以独立的变化
* 说明：  当两个类组群自建，关系呈现交叉组合的情况，可以通过桥接发方式，先把俩个组群的顶层抽象出来，然后在顶层包含引用，子类去调用另外一个组群的实现，实现了“抽象接口”和“实现接口”俩个部分，在抽象接口的实现类现在依赖“实现接口”的接口来实现功能，而不是通过实现类的子类来实现
* 范例：  
    当俩个组群因为功能上的需求，需要连接合作，但是又希望俩个组群可以格子发展不受彼此影响的时候，就可以考虑使用桥接模式。
    使用场景： 角色和装备、武器；角色和技能类型
* 优点：    
* 缺点：

### 策略模式（Strategy）

* 定义:   定义一组算法，并且封装每个算法，让他们可以彼此交换使用
* 说明：  
    抽象接口 Strategy： 提供 “策略客户端” 可以使用的方法
    策略实现类 StrategyA ... StrategyC等等：不同策略算法的实现
    策略客户端 Context： 拥有一个Strategy对象引用，通过对象引用获取想要的策略执行结果
* 范例：  
    使用场景：游戏中，各个渠道SDK的不同登录策略

* 优点：    策略模式里的每个策略实现类是相互独立的，类似于方法的抽象，各个解决方法之间没有联系。，强化项目的维护，方便迁移到其他项目
* 缺点：

### 模板方法模式（Template Method）

* 定义:   
* 说明：  
* 范例：  
* 优点：    
* 缺点：

### 建造者模式（Builder）

* 定义:   建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
* 说明：
    主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。
    一些基本部件不会变，而其组合经常变化的时候。
* 范例：  

* 优点：  
    1. 易于解耦 
        将产品本身与产品创建过程进行解耦，可以使用相同的创建过程来得到不同的产品。也就说细节依赖抽象。
    2. 易于精确控制对象的创建   
        将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰
    3. 易于拓展 
        增加新的具体建造者无需修改原有类库的代码，易于拓展，符合“开闭原则“。 
        每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。
* 缺点：
    1. 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
    2. 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。 

### 享元模式（Flyweight）

* 定义:   
* 说明：  
* 范例：  
* 优点：    
* 缺点：

### 组合模式（Composite）

* 定义:   
* 说明：  
* 范例：  
* 优点：    
* 缺点：

### 责任链模式（Chain of Responsibility）

* 定义:   
* 说明：  
* 范例：  
* 优点：    
* 缺点：

### 观察者模式（Observer）

* 定义:   

    定义了对象间一对多的依赖关系，当一个对象（主题Subject）状态发生改变时，所依赖它的对象（观察者Observer）将得到通知并自动更新状态。
    主题接口一般包含的方法：

    RegisterObserver（Observer o）：注册新的观察者
    RemoveObserver（Observer o）：删除旧的观察者
    Notify（…）：通知观察更新

    观察者接口一般包含相应的收到通知进行更新操作。

* 说明：  
* 范例：  
* 优点：  
    1、依赖接口编程，能够使不同系统通过低耦合的方式进行通信，减少了不相关系统间代码的耦合。
    2、容易实现一对多的依赖关系，只需要维护一个Observer数组就能给不同对象发送通知。  
* 缺点：
    1、Observer数组需要进行动态内存管理， 注册&删除要匹配
    2、通知信息是遍历Observer数组依次发送，在处理多线程问题时可能出现差错，前一个对象事件处理时间较长会造成下一个对象事件延迟。若观察者对象间存在联系，在执行顺序不同时可能会产生差错。

### 备忘录模式（Memento）

* 定义:   
* 说明：  
* 范例：  
* 优点：    
* 缺点：

### 访问者模式（Visitor）

* 定义:   
* 说明：  
* 范例：  
* 优点：    
* 缺点：

### 装饰模式（Decorator）

* 定义:   
* 说明：  
* 范例：  
* 优点：    
* 缺点：

### 适配器模式（Adapter）

* 定义:   
* 说明：  
* 范例：  
* 优点：    
* 缺点：

### 代理模式（Proxy）

* 定义:   
* 说明：  
* 范例：  
* 优点：    
* 缺点：

### xxx模式（xxx）

* 定义:   
* 说明：  
* 范例：  
* 优点：    
* 缺点：

## 代码重构

### 重构原则